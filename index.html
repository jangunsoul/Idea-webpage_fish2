<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reel 'Em All! – Prototype</title>
  <style>
    :root {
      --bg: #0b132b;
      --bg-light: #1c2541;
      --accent: #3a506b;
      --primary: #5bc0be;
      --secondary: #6fffe9;
      --text: #ffffff;
      --text-dim: #a0a9c0;
      --error: #ff6b6b;
      --success: #51cf66;
      --water1: #1e40af;
      --water2: #1e3a8a;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: var(--bg); 
      color: var(--text); 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      height: 100vh;
    }

    #game {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #view {
      display: block;
      width: 100%;
      height: 100%;
      background: var(--bg);
    }

    .hud {
      position: absolute;
      top: 20px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 20px;
      pointer-events: none;
      z-index: 10;
    }

    .pill {
      background: rgba(0, 0, 0, 0.7);
      color: var(--text);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      backdrop-filter: blur(10px);
    }

    .center-title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 20;
      color: var(--text);
    }

    .title {
      font-size: 3rem;
      font-weight: 800;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      font-size: 1.2rem;
      color: var(--text-dim);
      margin-bottom: 30px;
    }

    .tap {
      display: inline-block;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      color: white;
      padding: 15px 30px;
      border-radius: 25px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(91, 192, 190, 0.3);
    }

    .tap:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(91, 192, 190, 0.4);
    }

    .tap.disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .tap.error {
      background: linear-gradient(135deg, var(--error), #cc5252);
    }

    .version-tag {
      position: absolute;
      bottom: 10px;
      right: 10px;
      font-size: 0.8rem;
      color: var(--text-dim);
      opacity: 0.6;
    }

    .gauge {
      display: none;
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
    }

    .panel {
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .panel h3 {
      margin-bottom: 15px;
      color: var(--primary);
    }

    .bar {
      position: relative;
      width: 300px;
      height: 20px;
      background: var(--bg-light);
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }

    .sweet {
      position: absolute;
      left: 50%;
      top: 0;
      width: 60px;
      height: 100%;
      background: var(--error);
      transform: translateX(-50%);
      border-radius: 10px;
    }

    .cursor {
      position: absolute;
      top: 0;
      width: 5px;
      height: 100%;
      background: var(--secondary);
      border-radius: 2px;
    }

    .hint {
      font-size: 0.9rem;
      color: var(--text-dim);
      margin: 10px 0;
    }

    .tapto {
      background: var(--primary);
      color: white;
      padding: 8px 16px;
      border-radius: 15px;
      display: inline-block;
      font-size: 0.9rem;
      margin-top: 10px;
    }

    .toast {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 15px 25px;
      border-radius: 10px;
      font-weight: 600;
      z-index: 100;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .toast.show {
      transform: translate(-50%, -50%) scale(1);
    }

    .miss-effect {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      color: var(--error);
      font-size: 3rem;
      font-weight: 800;
      z-index: 50;
      pointer-events: none;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      transition: all 0.5s ease;
    }

    .miss-effect.show {
      transform: translate(-50%, -50%) scale(1.2);
      opacity: 0;
    }

    .distance {
      display: none;
      position: absolute;
      top: 70px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 16px;
      border-radius: 15px;
      font-weight: 600;
      z-index: 10;
      backdrop-filter: blur(10px);
    }

    .minimap {
      display: none;
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 15;
    }

    .minimap h4 {
      font-size: 0.9rem;
      margin-bottom: 10px;
      color: var(--primary);
      text-align: center;
    }

    .mmbar {
      position: relative;
      width: 120px;
      height: 60px;
      background: var(--bg-light);
      border-radius: 8px;
      overflow: hidden;
    }

    .mmcenter {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 4px;
      height: 4px;
      background: var(--secondary);
      transform: translate(-50%, -50%);
      border-radius: 50%;
    }

    .modal {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
      z-index: 100;
      backdrop-filter: blur(10px);
    }

    .card {
      background: var(--bg-light);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .card h3 {
      color: var(--primary);
      margin-bottom: 20px;
      font-size: 1.5rem;
    }

    .actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 20px;
    }

    .btn {
      padding: 10px 20px;
      border-radius: 15px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      background: var(--accent);
      color: white;
    }

    .btn.primary {
      background: var(--primary);
    }

    .btn:hover {
      transform: translateY(-2px);
      opacity: 0.9;
    }

    @media (max-width: 768px) {
      .title { font-size: 2rem; }
      .subtitle { font-size: 1rem; }
      .bar { width: 250px; }
      .hud { padding: 0 10px; }
    }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="view" aria-label="game view"></canvas>
    
    <div class="hud">
      <div class="left">
        <div class="pill">⚡ Energy: <span id="energy">10</span></div>
      </div>
      <div class="right">
        <div class="pill">🎣 Points: <span id="points">0</span></div>
      </div>
    </div>

    <div class="center-title" id="title">
      <div class="title">Reel 'Em All!</div>
      <div class="subtitle">릴럼올! – Touch to Start</div>
      <div class="tap" id="startBtn">Loading Assets...</div>
    </div>

    <div class="version-tag" id="versionTag" aria-hidden="true">Version v0.5.0-improved</div>

    <div class="gauge" id="gauge">
      <div class="panel">
        <h3>Cast Power</h3>
        <div class="bar" id="bar">
          <div class="sweet" id="sweet"></div>
          <div class="cursor" id="cursor"></div>
        </div>
        <div class="hint">Stop the cursor in the <b style="color:#ff8b8b">red</b> zone. Closer to the center = farther cast.</div>
        <div class="tap tapto">Tap / Click to Stop</div>
      </div>
    </div>

    <div class="toast" id="toast"></div>
    <div class="miss-effect" id="missEffect">MISS!</div>
    <div class="distance" id="distance"></div>

    <div class="minimap" id="minimap">
      <h4>Mini‑map (Detection Range)</h4>
      <div class="mmbar" id="mmbar"><div class="mmcenter"></div></div>
    </div>

    <div class="modal" id="results">
      <div class="card">
        <h3 id="rTitle">Catch Results</h3>
        <div id="rBody"></div>
        <div class="actions">
          <div class="btn" id="rSkip">Skip</div>
          <div class="btn primary" id="rNext">Next</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // === 유틸리티 함수들 ===
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    const rand = (min, max) => Math.random() * (max - min) + min;
    const randi = (min, max) => Math.floor(rand(min, max + 1));
    const pick = arr => arr[Math.floor(Math.random() * arr.length)];

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    function getCssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    // === 상수 정의 ===
    const GameState = {
      Idle: 'Idle',
      Casting: 'Casting', 
      Flight: 'Flight',
      Fishing: 'Fishing',
      Results: 'Results'
    };

    const RARITY_WEIGHTS = {
      Common: 100,
      Uncommon: 50,
      Rare: 20,
      Epic: 8,
      Legendary: 3,
      Mythic: 1
    };

    const FISH_SWIM_SPEED_TABLE = {
      Fast: 12,
      Normal: 8,
      Slow: 5
    };

    const DETECTION_RANGE_M = 5;

    // === 게임 상태 변수들 ===
    let canvas, ctx;
    let state = GameState.Idle;
    let globalTime = 0;
    let dataLoaded = false;
    let assetsReady = false;

    // DOM 요소들
    let startBtn, title, gauge, bar, sweet, cursor, toastEl, missEffect;
    let distanceEl, minimap, mmbar, results, rTitle, rBody, rNext, rSkip;
    let energyEl, pointsEl;

    // 게임 데이터
    const gameData = {
      species: [],
      resources: { fish: new Map() }
    };

    let SPECIES = [];

    // 게임 세팅
    const settings = {
      energy: 10,
      points: 0,
      baseCast: 30,
      maxCast: 200,
      rodTier: 1,
      lineTier: 1
    };

    // 월드 상태
    const world = {
      castDistance: 0,
      bobberDist: 0,
      fishes: [],
      actives: [],
      catches: [],
      time: 0
    };

    // 카메라와 렌더링
    const camera = { y: 0 };
    const rodAnchor = { x: 0, y: 0 };
    let baseX = 0;

    // 환경 상태
    const environmentState = {
      tileWidth: 40,
      tileHeight: 40, 
      landRows: 3,
      water: null,
      shore: null,
      land: null
    };

    // 캐릭터 스프라이트
    const characterSprite = {
      image: null,
      frameWidth: 40,
      frameHeight: 40,
      frameCount: 4,
      currentFrame: 0,
      idleFrame: 0,
      postCastFrame: 3,
      castSequence: [0, 1, 2, 3],
      frameDuration: 0.12,
      scale: 2.4,
      lineAnchor: { x: 30, y: 18 },
      playing: false,
      animationIndex: 0,
      timer: 0,
      holdFrame: 3
    };

    // === 물고기 데이터 ===
    const fishData = {
      species: [
        {
          id: "carp",
          displayName: "Common Carp", 
          rarity: "Common",
          size_cm: {min: 35, max: 80},
          weight_kg: {min: 1.0, max: 7.0},
          basePoints: 60,
          ui: {mapColorHex: "#8BC34A"},
          behavior: {
            swimSpeed: "Slow", 
            approachBias: 0.55,
            circleShrinkRate: 0.9
          },
          equipment: {recRodTier: 1, recLineTier: 1, breakRef_kg: 5},
          scoring: {rarityMult: 1.0, weightExp: 1.2, sizeExp: 0.8, distanceBonusCap: 1.15}
        },
        {
          id: "trout",
          displayName: "River Trout",
          rarity: "Uncommon", 
          size_cm: {min: 25, max: 60},
          weight_kg: {min: 0.5, max: 3.0},
          basePoints: 85,
          ui: {mapColorHex: "#00BCD4"},
          behavior: {
            swimSpeed: "Fast", 
            approachBias: 0.45,
            circleShrinkRate: 1.1
          },
          equipment: {recRodTier: 1, recLineTier: 1, breakRef_kg: 3.5},
          scoring: {rarityMult: 1.15, weightExp: 1.25, sizeExp: 0.9, distanceBonusCap: 1.18}
        },
        {
          id: "pike",
          displayName: "Northern Pike",
          rarity: "Rare",
          size_cm: {min: 50, max: 120},
          weight_kg: {min: 2.0, max: 14.0},
          basePoints: 160,
          ui: {mapColorHex: "#4CAF50"},
          behavior: {
            swimSpeed: "Fast", 
            approachBias: 0.4,
            circleShrinkRate: 1.2
          },
          equipment: {recRodTier: 2, recLineTier: 2, breakRef_kg: 8},
          scoring: {rarityMult: 1.35, weightExp: 1.35, sizeExp: 1.0, distanceBonusCap: 1.2}
        },
        {
          id: "salmon",
          displayName: "Coho Salmon",
          rarity: "Rare",
          size_cm: {min: 55, max: 90},
          weight_kg: {min: 2.0, max: 8.0},
          basePoints: 170,
          ui: {mapColorHex: "#F44336"},
          behavior: {
            swimSpeed: "Fast", 
            approachBias: 0.42,
            circleShrinkRate: 1.15
          },
          equipment: {recRodTier: 2, recLineTier: 2, breakRef_kg: 6.5},
          scoring: {rarityMult: 1.35, weightExp: 1.35, sizeExp: 1.0, distanceBonusCap: 1.2}
        },
        {
          id: "koi_golden",
          displayName: "Golden Koi",
          rarity: "Epic",
          size_cm: {min: 35, max: 75},
          weight_kg: {min: 1.0, max: 6.0},
          basePoints: 240,
          ui: {mapColorHex: "#FFC107"},
          behavior: {
            swimSpeed: "Slow", 
            approachBias: 0.35,
            circleShrinkRate: 1.0
          },
          equipment: {recRodTier: 2, recLineTier: 2, breakRef_kg: 6},
          scoring: {rarityMult: 1.6, weightExp: 1.3, sizeExp: 1.1, distanceBonusCap: 1.18}
        },
        {
          id: "sturgeon",
          displayName: "River Sturgeon",
          rarity: "Legendary",
          size_cm: {min: 80, max: 180},
          weight_kg: {min: 6.0, max: 40.0},
          basePoints: 420,
          ui: {mapColorHex: "#607D8B"},
          behavior: {
            swimSpeed: "Normal", 
            approachBias: 0.3,
            circleShrinkRate: 1.25
          },
          equipment: {recRodTier: 3, recLineTier: 3, breakRef_kg: 18},
          scoring: {rarityMult: 2.1, weightExp: 1.45, sizeExp: 1.1, distanceBonusCap: 1.2}
        }
      ]
    };

    // === 에셋 로딩 시스템 ===
    async function loadGameAssets() {
      try {
        // 기본 데이터 설정
        gameData.species = fishData.species;
        SPECIES = gameData.species;
        
        const assetTasks = [];
        
        // 환경 에셋들 - 실제 파일 경로로 시도, 실패시 폴백
        const environmentAssets = [
          { key: 'water', paths: ['assets/characters/river.png', 'data/river.png', './river.png'] },
          { key: 'shore', paths: ['assets/characters/land01.png', 'data/land01.png', './land01.png'] },  
          { key: 'land', paths: ['assets/characters/land02.png', 'data/land02.png', './land02.png'] }
        ];
        
        for (const asset of environmentAssets) {
          assetTasks.push(
            loadImageWithFallback(asset.paths).then(img => {
              if (img) {
                environmentState[asset.key] = img;
                if (asset.key === 'shore') {
                  environmentState.tileWidth = img.width;
                  environmentState.tileHeight = img.height;
                }
                console.log(`✓ Loaded ${asset.key}`);
              }
            }).catch(err => {
              console.warn(`Failed to load ${asset.key}, using fallback`);
            })
          );
        }
        
        // 캐릭터 스프라이트
        assetTasks.push(
          loadImageWithFallback(['assets/characters/char.png', 'data/char.png', './char.png']).then(img => {
            if (img) {
              characterSprite.image = img;
              console.log('✓ Loaded character sprite');
            }
          }).catch(err => {
            console.warn('Failed to load character sprite, using fallback');
          })
        );
        
        // 물고기 에셋들
        const fishAssetMap = {
          'carp': ['assets/fish/carp.png', 'data/carp.png', './carp.png'],
          'trout': ['assets/fish/trout.png', 'data/trout.png', './trout.png'], 
          'pike': ['assets/fish/pike.png', 'data/pike.png', './pike.png'],
          'salmon': ['assets/fish/salmon.png', 'data/salmon.png', './salmon.png'],
          'koi_golden': ['assets/fish/koi_golden.png', 'data/koi_golden.png', './koi_golden.png'],
          'sturgeon': ['assets/fish/sturgeon.png', 'data/sturgeon.png', './sturgeon.png']
        };
        
        for (const [speciesId, paths] of Object.entries(fishAssetMap)) {
          assetTasks.push(
            loadImageWithFallback(paths).then(img => {
              if (img) {
                gameData.resources.fish.set(speciesId, img);
                console.log(`✓ Loaded fish: ${speciesId}`);
              }
            }).catch(err => {
              console.warn(`Failed to load fish ${speciesId}, using fallback`);
            })
          );
        }
        
        // 모든 에셋 로딩 완료 대기
        await Promise.all(assetTasks);
        
        dataLoaded = true;
        assetsReady = true;
        
        // 로딩된 에셋 개수 보고
        const loadedFish = gameData.resources.fish.size;
        const loadedEnv = [environmentState.water, environmentState.shore, environmentState.land].filter(x => x).length;
        console.log(`Assets loaded - Fish: ${loadedFish}/6, Environment: ${loadedEnv}/3, Character: ${characterSprite.image ? 1 : 0}/1`);
        
        return true;
        
      } catch (err) {
        console.error('Failed to load game assets:', err);
        // 에셋 로딩 실패해도 게임은 계속 진행 (폴백 그래픽 사용)
        dataLoaded = true;
        assetsReady = true;
        return true;
      }
    }

    // 여러 경로로 이미지 로딩 시도
    function loadImageWithFallback(paths) {
      return new Promise((resolve, reject) => {
        let attemptIndex = 0;
        
        function tryNext() {
          if (attemptIndex >= paths.length) {
            resolve(null); // 모든 경로 실패시 null 반환 (폴백 사용)
            return;
          }
          
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => resolve(img);
          img.onerror = () => {
            attemptIndex++;
            tryNext();
          };
          img.src = paths[attemptIndex];
        }
        
        tryNext();
      });
    }

    // === 물고기 AI 시스템 ===
    function getFishMoveBias(spec) {
      const tag = spec?.behavior?.swimSpeed || 'Normal';
      if (tag === 'Fast') return 0.7;
      if (tag === 'Slow') return 0.4;
      return 0.55;
    }

    function getFishSwimSpeed(spec, weightKg) {
      const tag = spec?.behavior?.swimSpeed || 'Normal';
      const base = FISH_SWIM_SPEED_TABLE[tag] ?? FISH_SWIM_SPEED_TABLE.Normal;
      const range = (spec?.weight_kg?.max ?? 0) - (spec?.weight_kg?.min ?? 0);
      const minW = spec?.weight_kg?.min ?? weightKg;
      const norm = range > 0 ? clamp((weightKg - minW) / range, 0, 1) : 0.5;
      const heavinessAdjust = lerp(1.15, 0.85, norm);
      return base * heavinessAdjust;
    }

    function updateFishSimulation(dt) {
      if (!world.fishes || !world.fishes.length) return;
      
      const bobberPos = { x: 0, y: world.bobberDist };
      
      for (const fish of world.fishes) {
        if (!fish || fish.finished) continue;
        
        // 필수 속성 초기화
        if (!fish.position) fish.position = { x: rand(-26, 26), y: fish.distance ?? 30 };
        if (!fish.velocity) fish.velocity = { x: 0, y: 0 };
        if (!fish.targetVelocity) fish.targetVelocity = { x: 0, y: 0 };
        if (typeof fish.stressLevel !== 'number') fish.stressLevel = 0;
        if (typeof fish.personalityFactor !== 'number') fish.personalityFactor = rand(0.8, 1.2);
        if (typeof fish.escapeTimer !== 'number') fish.escapeTimer = 0;
        
        fish.escapeTimer = Math.max(0, fish.escapeTimer - dt);
        
        // 찌와의 거리 계산
        const dx = fish.position.x - bobberPos.x;
        const dy = fish.position.y - bobberPos.y;
        const distToBobber = Math.sqrt(dx * dx + dy * dy);
        
        // 스트레스 계산
        if (distToBobber < 8) {
          fish.stressLevel = Math.min(1.0, fish.stressLevel + dt * 0.3);
        } else {
          fish.stressLevel = Math.max(0, fish.stressLevel - dt * 0.1);
        }

        // AI 기반 움직임 (2% 확률로 업데이트)
        if (Math.random() < 0.02) {
          const wanderAngle = globalTime * 0.5 + fish.specId.charCodeAt(0) * 0.1;
          const wanderRadius = 0.3;
          
          let finalX = Math.cos(wanderAngle) * wanderRadius;
          let finalY = Math.sin(wanderAngle) * wanderRadius * 0.7;
          
          // 회피 행동
          if (distToBobber < 8) {
            const force = (8 - distToBobber) / 8;
            const normalizedX = dx / (distToBobber + 0.1);
            const normalizedY = dy / (distToBobber + 0.1);
            finalX += normalizedX * force * 2.5;
            finalY += normalizedY * force * 2.5;
          }
          
          const magnitude = Math.sqrt(finalX * finalX + finalY * finalY);
          if (magnitude > 0.1) {
            const speed = (fish.swimSpeed || 8) * fish.personalityFactor;
            fish.targetVelocity.x = (finalX / magnitude) * speed;
            fish.targetVelocity.y = (finalY / magnitude) * speed * 0.7;
            fish.moving = true;
          } else if (Math.random() > (fish.moveBias || 0.5)) {
            fish.targetVelocity.x = 0;
            fish.targetVelocity.y = 0;
            fish.moving = false;
          }
        }
        
        // 속도 스무딩
        const velocitySmooth = 1 - Math.pow(0.001, dt * 9);
        fish.velocity.x += (fish.targetVelocity.x - fish.velocity.x) * velocitySmooth;
        fish.velocity.y += (fish.targetVelocity.y - fish.velocity.y) * velocitySmooth;
        
        // 위치 업데이트
        fish.position.x += fish.velocity.x * dt;
        fish.position.y += fish.velocity.y * dt;
        
        // 경계 처리
        let clamped = false;
        if (fish.position.y < 30) { fish.position.y = 30; clamped = true; }
        if (fish.position.y > 200) { fish.position.y = 200; clamped = true; }
        if (fish.position.x < -52) { fish.position.x = -52; clamped = true; }
        if (fish.position.x > 52) { fish.position.x = 52; clamped = true; }
        
        if (clamped) {
          fish.targetVelocity.x *= -0.3;
          fish.targetVelocity.y *= -0.3;
        }
        
        // 거의 정지한 경우 완전 정지
        const speedSq = fish.velocity.x * fish.velocity.x + fish.velocity.y * fish.velocity.y;
        if (speedSq < 0.01 && !fish.moving) {
          fish.velocity.x = 0;
          fish.velocity.y = 0;
        }
        
        fish.distance = fish.position.y;
      }
    }

    // === 렌더링 시스템 ===
    function getEnvironmentMetrics(W, H) {
      const tileW = Math.max(1, Math.round(environmentState.tileWidth || 40));
      const tileH = Math.max(1, Math.round(environmentState.tileHeight || 40));
      const configuredStrips = Math.max(1, Math.floor(environmentState.landRows || 3));
      const desiredLand = tileH * configuredStrips;
      const minLand = tileH * 2;
      const minWater = Math.max(tileH * 3, 160);
      const landHeight = Math.min(Math.max(minLand, desiredLand), Math.max(minLand, H - minWater));
      const shorelineY = Math.max(0, H - landHeight);
      
      let waterSurfaceY = shorelineY - Math.min(tileH * 0.6, 48);
      waterSurfaceY = Math.min(waterSurfaceY, shorelineY - 4);
      waterSurfaceY = Math.max(20, waterSurfaceY);
      if (shorelineY < 24) waterSurfaceY = Math.max(4, shorelineY * 0.6);

      const topMargin = Math.max(tileH * 1.5, Math.min(shorelineY * 0.45, 160));
      const targetBobberY = Math.min(shorelineY - tileH * 1.4, Math.max(topMargin + tileH * 2, H * 0.35));
      const available = Math.max(tileH * 2, shorelineY - topMargin);
      const minScrollRange = H * 3;
      let pxPerMeter = available / Math.max(1, settings.maxCast);
      if (pxPerMeter * settings.maxCast < minScrollRange) pxPerMeter = minScrollRange / Math.max(1, settings.maxCast);
      
      const distancePxRange = pxPerMeter * settings.maxCast;
      const minBaseY = waterSurfaceY - distancePxRange;
      const maxScroll = Math.max(0, targetBobberY - minBaseY);
      const bobberOffsetX = Math.max(4, (characterSprite.scale || 2) * 1.2);

      return {
        tileW, tileH, landHeight, shorelineY, waterSurfaceY, topMargin, targetBobberY,
        pxPerMeter, distancePxRange, maxScroll, bobberOffsetX
      };
    }

    function drawEnvironment(W, H, metrics, cameraY) {
      ctx.fillStyle = getCssVar('--bg');
      ctx.fillRect(0, 0, W, H);

      const tileW = Math.max(1, Math.round(metrics.tileW));
      const tileH = Math.max(1, Math.round(metrics.tileH));
      const shorelineY = metrics.shorelineY;
      const firstWaterY = Math.floor((-cameraY - tileH * 2) / tileH) * tileH;

      // 물 그리기
      for (let worldY = firstWaterY; worldY < shorelineY; worldY += tileH) {
        const screenY = worldY + cameraY;
        if (screenY > H) break;
        drawWaterRow(screenY, tileW, tileH, W);
      }

      // 육지 그리기
      const landLayers = Math.max(1, Math.ceil(metrics.landHeight / tileH));
      let worldY = shorelineY;
      for (let layer = 0; layer < landLayers + 2; layer++) {
        const screenY = worldY + cameraY;
        drawLandRow(screenY, tileW, tileH, W, layer === 0);
        worldY += tileH;
        if (screenY > H + tileH) break;
      }
    }

    function drawWaterRow(y, tileW, tileH, width) {
      if (environmentState.water) {
        const tilesNeeded = Math.ceil(width / tileW) + 2;
        const startX = -tileW;
        for (let i = 0; i < tilesNeeded; i++) {
          const x = startX + i * tileW;
          ctx.drawImage(environmentState.water, x, y, tileW, tileH);
        }
      } else {
        // 향상된 폴백: 더 사실적인 물 그래픽
        const time = globalTime * 0.5;
        const wave1 = Math.sin(time + y * 0.01) * 0.1;
        const wave2 = Math.cos(time * 1.3 + y * 0.008) * 0.05;
        const waveOffset = (wave1 + wave2) * 10;
        
        const grd = ctx.createLinearGradient(0, y + waveOffset, 0, y + tileH + waveOffset);
        grd.addColorStop(0, '#1e40af');
        grd.addColorStop(0.3, '#1d4ed8');
        grd.addColorStop(0.7, '#2563eb');
        grd.addColorStop(1, '#1e3a8a');
        ctx.fillStyle = grd;
        ctx.fillRect(0, y, width, tileH);
        
        // 물결 효과 추가
        ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
        const waveY = y + tileH * 0.3 + Math.sin(time * 2 + y * 0.02) * 5;
        ctx.fillRect(0, waveY, width, 2);
      }
    }

    function drawLandRow(y, tileW, tileH, width, shoreline) {
      const img = shoreline ? environmentState.shore : (environmentState.land || environmentState.shore);
      if (img) {
        const tilesNeeded = Math.ceil(width / tileW) + 2;
        const startX = -tileW;
        for (let i = 0; i < tilesNeeded; i++) {
          const x = startX + i * tileW;
          ctx.drawImage(img, x, y, tileW, tileH);
        }
      } else {
        // 향상된 폴백: 더 사실적인 땅 그래픽
        if (shoreline) {
          // 해안선
          const grd = ctx.createLinearGradient(0, y, 0, y + tileH);
          grd.addColorStop(0, '#8b7355');
          grd.addColorStop(0.5, '#6d5a47');
          grd.addColorStop(1, '#5a4a3a');
          ctx.fillStyle = grd;
          ctx.fillRect(0, y, width, tileH);
          
          // 모래/자갈 텍스처 효과
          ctx.fillStyle = 'rgba(139, 115, 85, 0.3)';
          for (let i = 0; i < width; i += 8) {
            if (Math.random() > 0.7) {
              ctx.fillRect(i, y + Math.random() * tileH, 2, 2);
            }
          }
        } else {
          // 일반 땅
          const grd = ctx.createLinearGradient(0, y, 0, y + tileH);
          grd.addColorStop(0, '#4a5d3a');
          grd.addColorStop(0.5, '#3d4f2f');
          grd.addColorStop(1, '#2f3d23');
          ctx.fillStyle = grd;
          ctx.fillRect(0, y, width, tileH);
          
          // 풀밭 효과
          ctx.fillStyle = 'rgba(74, 93, 58, 0.4)';
          for (let i = 0; i < width; i += 12) {
            if (Math.random() > 0.6) {
              ctx.fillRect(i, y + tileH * 0.1, 1, tileH * 0.3);
            }
          }
        }
      }
    }

    function updateCharacterAnimation(dt) {
      const sprite = characterSprite;
      if (!sprite) return;

      const sequence = Array.isArray(sprite.castSequence) ? sprite.castSequence : [];
      const frameDuration = typeof sprite.frameDuration === 'number' && sprite.frameDuration > 0 
        ? sprite.frameDuration : 0.1;

      if (sprite.playing && sequence.length) {
        sprite.timer += dt;
        if (sprite.timer >= frameDuration) {
          sprite.timer -= frameDuration;
          sprite.animationIndex++;
          if (sprite.animationIndex >= sequence.length) {
            sprite.playing = false;
            const hold = sprite.holdFrame ?? sprite.postCastFrame;
            if (typeof hold === 'number') sprite.currentFrame = hold;
          } else {
            const next = sequence[sprite.animationIndex];
            if (typeof next === 'number') sprite.currentFrame = next;
          }
        }
      } else if (state === GameState.Idle || state === GameState.Casting) {
        sprite.currentFrame = sprite.idleFrame || 0;
      }
    }

    function drawCharacterSprite(W, H, metrics, cameraY) {
      const sprite = characterSprite;
      const scale = sprite.scale || 2;
      const frameW = sprite.frameWidth;
      const frameH = sprite.frameHeight;
      const destW = frameW * scale;
      const destH = frameH * scale;
      const charBaseX = W * 0.5 - destW * 0.5;
      baseX = charBaseX;
      const baseY = metrics.shorelineY + metrics.tileH * 0.2 - destH;
      const drawY = baseY + cameraY;

      if (sprite.image) {
        const index = Math.max(0, Math.min(sprite.frameCount - 1, Math.floor(sprite.currentFrame)));
        const sx = index * frameW;
        ctx.drawImage(sprite.image, sx, 0, frameW, frameH, charBaseX, drawY, destW, destH);
      } else {
        // 향상된 폴백 캐릭터
        // 몸통
        const bodyColor = '#2dd4bf';
        const shirtColor = '#1d4ed8';
        const skinColor = '#f4a261';
        
        // 머리
        ctx.fillStyle = skinColor;
        ctx.beginPath();
        ctx.arc(charBaseX + destW/2, drawY + 25, 18, 0, Math.PI * 2);
        ctx.fill();
        
        // 몸통
        ctx.fillStyle = shirtColor;
        ctx.fillRect(charBaseX + destW/2 - 22, drawY + 35, 44, 50);
        
        // 팔 (낚싯대를 든 자세)
        ctx.fillStyle = skinColor;
        if (sprite.currentFrame >= 2) {
          // 캐스팅 자세
          ctx.fillRect(charBaseX + destW/2 + 15, drawY + 40, 15, 8);
          ctx.fillRect(charBaseX + destW/2 - 30, drawY + 35, 15, 8);
        } else {
          // 기본 자세  
          ctx.fillRect(charBaseX + destW/2 + 20, drawY + 45, 12, 25);
          ctx.fillRect(charBaseX + destW/2 - 32, drawY + 45, 12, 25);
        }
        
        // 다리
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(charBaseX + destW/2 - 18, drawY + 85, 14, 30);
        ctx.fillRect(charBaseX + destW/2 + 4, drawY + 85, 14, 30);
        
        // 낚싯대
        ctx.strokeStyle = '#8b5a3c';
        ctx.lineWidth = 3;
        ctx.beginPath();
        if (sprite.currentFrame >= 2) {
          // 캐스팅 자세의 낚싯대
          ctx.moveTo(charBaseX + destW/2 + 20, drawY + 45);
          ctx.lineTo(charBaseX + destW/2 + 40, drawY + 20);
        } else {
          // 기본 자세의 낚싯대
          ctx.moveTo(charBaseX + destW/2 + 25, drawY + 50);
          ctx.lineTo(charBaseX + destW/2 + 45, drawY + 25);
        }
        ctx.stroke();
      }

      const anchor = sprite.lineAnchor || { x: frameW - 6, y: frameH * 0.5 };
      const spriteScale = sprite.scale || scale;
      rodAnchor.x = baseX + anchor.x * spriteScale;
      rodAnchor.y = drawY + anchor.y * spriteScale;
    }

    function drawFishingLine(ax, ay, bx, by) {
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 2;
      ctx.beginPath();
      const sway = Math.sin(globalTime * 2.1) * 8;
      const ctrlX = ax + sway;
      const ctrlY = Math.min(ay - Math.max(60, Math.abs(by - ay) * 0.6), by - 18);
      ctx.moveTo(ax, ay);
      ctx.quadraticCurveTo(ctrlX, ctrlY, bx, by - 6);
      ctx.stroke();
    }

    function drawBobber(x, y) {
      ctx.fillStyle = '#ef4444';
      ctx.beginPath(); 
      ctx.arc(x, y, 7, 0, Math.PI * 2); 
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); 
      ctx.arc(x, y - 2, 3, 0, Math.PI * 2); 
      ctx.fill();
    }

    function updateCamera(distance, metrics, dt, state) {
      const distancePx = clamp(distance * metrics.pxPerMeter, 0, metrics.distancePxRange);
      const baseY = metrics.waterSurfaceY - distancePx;
      let desired = 0;
      if (state === GameState.Flight || state === GameState.Fishing) {
        desired = clamp(metrics.targetBobberY - baseY, 0, metrics.maxScroll);
      }
      const smoothing = 1 - Math.pow(0.001, dt * 9);
      camera.y += (desired - camera.y) * smoothing;
      camera.y = clamp(camera.y, 0, metrics.maxScroll);
      return { distancePx, baseY };
    }

    // === 게임플레이 로직 ===
    function sampleSpecies() {
      if (!SPECIES.length) return null;
      const pool = [];
      for (const s of SPECIES) {
        const w = RARITY_WEIGHTS[s.rarity] || 1;
        for (let i = 0; i < w; i++) pool.push(s);
      }
      if (!pool.length) return null;
      return pick(pool);
    }

    function spawnFishes(dist, metrics, viewportWidth) {
      if (!SPECIES.length) return { fishes: [], lateralLimit: 26, displayRange: 26 };
      
      const ratio = clamp(dist / settings.maxCast, 0.2, 1);
      const count = randi(4 + ratio * 2, 6 + ratio * 3);
      const fishes = [];
      
      for (let i = 0; i < count; i++) {
        const spec = sampleSpecies();
        if (!spec) continue;
        
        const size = rand(spec.size_cm.min, spec.size_cm.max);
        const weight = rand(spec.weight_kg.min, spec.weight_kg.max);
        const distance = rand(30, Math.min(dist + 20, 200));
        const lateral = rand(-26, 26);
        
        const fish = {
          specId: spec.id, spec, distance, size_cm: size, weight_kg: weight, engaged: false, finished: false,
          iconColor: spec.ui.mapColorHex, position: { x: lateral, y: distance },
          velocity: { x: 0, y: 0 }, targetVelocity: { x: 0, y: 0 }, bonusMultiplier: 1,
          escapeTimer: 0, lastCircleTime: -Infinity, renderCache: null, image: null, active: null,
          stressLevel: 0, personalityFactor: rand(0.8, 1.2), moveBias: getFishMoveBias(spec),
          swimSpeed: getFishSwimSpeed(spec, weight)
        };
        fishes.push(fish);
      }
      
      if (fishes.length) {
        const pool = fishes.slice();
        const special = pool.splice(Math.floor(Math.random() * pool.length), 1)[0];
        if (special) special.bonusMultiplier = 2;
        if (pool.length && Math.random() < 0.25) {
          const rare = pool.splice(Math.floor(Math.random() * pool.length), 1)[0];
          if (rare) rare.bonusMultiplier = 3;
        }
      }
      
      fishes.sort((a, b) => a.distance - b.distance);
      return { fishes, lateralLimit: 52, displayRange: 26 };
    }

    function rollCatch(active) {
      const f = active.fish;
      const spec = f.spec;
      const r = clamp((active.radius - active.minR) / (active.maxR - active.minR), 0, 1);
      const skill = 1 - r;
      
      let p = 0.15 + 0.75 * skill;
      p *= (0.8 + 0.5 * spec.behavior.approachBias);
      
      const stressPenalty = 1 - (f.stressLevel * 0.2);
      p *= stressPenalty;
      p = clamp(p, 0.05, 0.98);
      
      const difficultyMultiplier = {
        Common: 1.15,
        Uncommon: 1.05,
        Rare: 0.95,
        Epic: 0.85,
        Legendary: 0.75,
        Mythic: 0.65
      }[spec.rarity] || 1;
      
      p *= difficultyMultiplier;
      return Math.random() < p;
    }

    function computePoints(fish, castDistance) {
      const s = fish.spec;
      const sc = s.scoring;
      const wNorm = (fish.weight_kg - s.weight_kg.min) / (s.weight_kg.max - s.weight_kg.min);
      const szNorm = (fish.size_cm - s.size_cm.min) / (s.size_cm.max - s.size_cm.min);
      const distanceFactor = clamp(1.0 + 0.20 * (castDistance - settings.baseCast) / (settings.maxCast - settings.baseCast), 1.0, sc.distanceBonusCap || 1.20);
      const baseScore = s.basePoints * sc.rarityMult * Math.pow(1 + clamp(wNorm,0,1), sc.weightExp) * Math.pow(1 + clamp(szNorm,0,1), sc.sizeExp) * distanceFactor;
      const multiplier = Math.max(1, fish?.bonusMultiplier || 1);
      return Math.round(baseScore * multiplier);
    }

    function releaseActiveCircle(active, applyRetreat = true) {
      if (!active) return;
      const fish = active.fish;
      if (fish) {
        if (fish.active === active) fish.active = null;
        fish.engaged = false;
        if (!fish.finished && applyRetreat) {
          const posY = fish.position?.y ?? fish.distance ?? 0;
          const posX = fish.position?.x ?? 0;
          const escape = Math.atan2(posY - world.bobberDist, posX) + Math.PI + rand(-0.45, 0.45);
          const speed = (fish.swimSpeed || 10) * rand(1.2, 1.6) * fish.personalityFactor;
          if (fish.targetVelocity) {
            fish.targetVelocity.x = Math.cos(escape) * speed;
            fish.targetVelocity.y = Math.sin(escape) * speed * 0.7;
          }
          fish.escapeTimer = rand(1.0, 2.0);
          fish.stressLevel = Math.min(1.0, fish.stressLevel + 0.3);
        }
      }
      active.life = 0;
    }

    function updateActiveCircles(dt, bx, by, metrics, cameraY) {
      const pxPerMeter = metrics?.pxPerMeter || (canvas.clientHeight / Math.max(1, settings.maxCast));
      const baseLife = 1.8;

      for (const fish of world.fishes) {
        if (!fish || fish.finished) continue;

        const centerY = fish.position?.y ?? fish.distance;
        const centerX = fish.position?.x ?? 0;
        const range = DETECTION_RANGE_M;
        
        const dy = centerY - world.bobberDist;
        const dx = centerX;
        const distToBobber = Math.sqrt(dx * dx + dy * dy);

        if (distToBobber <= range) {
          if (!fish.active) {
            const maxR = Math.max(24, range * pxPerMeter * 0.4);
            const minR = Math.max(12, maxR * 0.35);
            const shrinkRate = 15 + 20 * (fish.spec?.behavior?.circleShrinkRate ?? 1);
            const active = { fish, radius: maxR, maxR, minR, life: baseLife, range, shrinkRate, detectionRange: range };
            fish.engaged = true;
            fish.lastCircleTime = globalTime;
            fish.active = active;
            world.actives.push(active);
          }
        } else if (fish.active && distToBobber > range * 1.2) {
          fish.active.life = Math.min(fish.active.life, 0);
        } else if (!fish.active) {
          fish.engaged = false;
        }
      }

      const kept = [];
      for (const active of world.actives) {
        const fish = active.fish;
        if (!fish || fish.finished) {
          releaseActiveCircle(active, false);
          continue;
        }

        const centerY = fish.position?.y ?? fish.distance;
        const centerX = fish.position?.x ?? 0;
        const dy = centerY - world.bobberDist;
        const dx = centerX;
        const distToBobber = Math.sqrt(dx * dx + dy * dy);

        if (distToBobber > active.detectionRange * 1.3) {
          releaseActiveCircle(active, true);
          continue;
        }

        const proximityFactor = active.detectionRange > 0 ? clamp(1 - distToBobber / active.detectionRange, 0, 1) : 1;
        const targetRadius = lerp(active.maxR, active.minR, proximityFactor * 0.7);
        
        const blend = clamp(dt * 8, 0, 1);
        active.radius += (targetRadius - active.radius) * blend;
        active.radius = clamp(active.radius, active.minR, active.maxR);
        active.radius = Math.max(active.minR, active.radius - active.shrinkRate * dt);
        active.life -= dt;

        const alpha = clamp(active.life / baseLife, 0.3, 1.0);
        const pulseEffect = 1 + Math.sin(globalTime * 8) * 0.1;
        
        ctx.strokeStyle = fish.spec.ui.mapColorHex;
        ctx.lineWidth = 4 * pulseEffect;
        ctx.globalAlpha = alpha;
        ctx.beginPath(); 
        ctx.arc(bx, by, active.radius, 0, Math.PI * 2); 
        ctx.stroke();
        
        if (active.radius <= active.minR + 8) {
          ctx.strokeStyle = '#22c55e';
          ctx.lineWidth = 2;
          ctx.globalAlpha = alpha * 0.6;
          ctx.beginPath(); 
          ctx.arc(bx, by, active.minR, 0, Math.PI * 2); 
          ctx.stroke();
        }
        
        ctx.globalAlpha = 1;

        if (active.life > 0 && active.radius > active.minR + 0.5) {
          kept.push(active);
        } else {
          releaseActiveCircle(active, true);
        }
      }
      world.actives = kept;
    }

    // === 유틸리티 함수들 ===
    function showToast(msg) {
      if (!toastEl) return;
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      setTimeout(() => toastEl.classList.remove('show'), 2000);
    }

    function showMissEffect() {
      missEffect.classList.remove('show');
      void missEffect.offsetWidth;
      missEffect.classList.add('show');
      setTimeout(() => missEffect.classList.remove('show'), 500);
    }

    function setHUD() {
      energyEl.textContent = settings.energy;
      pointsEl.textContent = settings.points;
    }

    function setGameplayLayout(gameplay) {
      if (gameplay) {
        title.style.display = 'none';
        canvas.style.cursor = 'crosshair';
        distanceEl.style.display = 'block';
        document.querySelector('.hud').style.display = 'flex';
      } else {
        title.style.display = 'flex';
        canvas.style.cursor = 'default';
        distanceEl.style.display = 'none';
        minimap.style.display = 'none';
        gauge.style.display = 'none';
      }
    }

    function resetCharacterToIdle() {
      characterSprite.playing = false;
      characterSprite.animationIndex = 0;
      characterSprite.timer = 0;
      characterSprite.currentFrame = characterSprite.idleFrame || 0;
      characterSprite.holdFrame = characterSprite.postCastFrame ?? characterSprite.currentFrame;
    }

    function startCharacterCastAnimation() {
      if (!characterSprite.castSequence.length) return;
      characterSprite.playing = true;
      characterSprite.animationIndex = 0;
      characterSprite.timer = 0;
      characterSprite.currentFrame = characterSprite.castSequence[0] ?? 0;
      characterSprite.holdFrame = characterSprite.postCastFrame ?? characterSprite.castSequence[characterSprite.castSequence.length - 1] ?? characterSprite.currentFrame;
    }

    // 게임 초기화
    async function init() {
      // DOM 요소들 가져오기
      canvas = document.getElementById('view');
      ctx = canvas.getContext('2d');
      startBtn = document.getElementById('startBtn');
      title = document.getElementById('title');
      gauge = document.getElementById('gauge');
      bar = document.getElementById('bar');
      sweet = document.getElementById('sweet');
      cursor = document.getElementById('cursor');
      toastEl = document.getElementById('toast');
      missEffect = document.getElementById('missEffect');
      distanceEl = document.getElementById('distance');
      minimap = document.getElementById('minimap');
      mmbar = document.getElementById('mmbar');
      results = document.getElementById('results');
      rTitle = document.getElementById('rTitle');
      rBody = document.getElementById('rBody');
      rNext = document.getElementById('rNext');
      rSkip = document.getElementById('rSkip');
      energyEl = document.getElementById('energy');
      pointsEl = document.getElementById('points');

      // 캔버스 크기 설정
      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // 게임 에셋 로딩
      const success = await loadGameAssets();
      
      if (success) {
        startBtn.textContent = 'Touch to Start';
        startBtn.classList.remove('disabled');
        setHUD();
      } else {
        startBtn.textContent = 'Failed to Load - Retry';
        startBtn.classList.add('error');
      }

      // 이벤트 리스너 설정
      startBtn.addEventListener('click', async () => {
        if (!dataLoaded || !assetsReady) {
          startBtn.textContent = 'Loading Assets...';
          startBtn.classList.add('disabled');
          const success = await loadGameAssets();
          if (success) {
            startBtn.textContent = 'Touch to Start';
            startBtn.classList.remove('disabled', 'error');
          } else {
            startBtn.textContent = 'Failed to Load - Retry';
            startBtn.classList.add('error');
          }
          return;
        }
        if (state !== GameState.Idle) return;
        if (settings.energy <= 0) { 
          showToast('Not enough energy.'); 
          return; 
        }
        startCasting();
      });

      canvas.addEventListener('click', () => {
        if (state === GameState.Idle) startCasting();
      });

      window.addEventListener('pointerdown', () => {
        if (state === GameState.Fishing) {
          const anyActive = world.actives.length > 0;
          let caughtNow = [];
          for (const a of world.actives) {
            const success = rollCatch(a);
            if (success) caughtNow.push(a.fish);
          }
          if (caughtNow.length) {
            for (const f of caughtNow) {
              if (f.active) releaseActiveCircle(f.active, false);
              f.finished = true;
              f.engaged = false;
              world.catches.push(f);
            }
            showResults();
          } else if (anyActive) {
            showMissEffect();
          }
        }
      });

      rNext.addEventListener('click', () => {
        rIndex++;
        if (rIndex < world.catches.length) {
          renderResultCard();
        } else {
          results.style.display = 'none';
          state = GameState.Idle;
          title.style.display = 'flex';
          resetCharacterToIdle();
          setGameplayLayout(false);
        }
      });

      rSkip.addEventListener('click', () => {
        results.style.display = 'none';
        state = GameState.Idle;
        title.style.display = 'flex';
        resetCharacterToIdle();
        setGameplayLayout(false);
      });
    }

    function startCasting() {
      setGameplayLayout(true);
      camera.y = 0;
      settings.energy--; 
      setHUD();
      title.style.display = 'none';
      gauge.style.display = 'flex';
      state = GameState.Casting;
      
      const barRect = bar.getBoundingClientRect();
      const w = barRect.width, cursorW = 5;
      let dir = 1, x = 0;
      const speed = w * 1.4;

      function frame(ts) {
        if (state !== GameState.Casting) return;
        if (!frame.last) frame.last = ts;
        const dt = (ts - frame.last)/1000; 
        frame.last = ts;
        x += dir * speed * dt;
        if (x <= 0) { x = 0; dir = 1; }
        if (x >= w - cursorW) { x = w - cursorW; dir = -1; }
        cursor.style.left = x + 'px';
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);

      const stop = () => {
        bar.removeEventListener('click', stop);
        gauge.style.display = 'none';
        const sweetRect = sweet.getBoundingClientRect();
        const sweetCenter = sweetRect.left + sweetRect.width/2;
        const cursorCenter = barRect.left + x + cursorW/2;
        const dx = Math.abs(cursorCenter - sweetCenter);
        const max = sweetRect.width/2;
        const closeness = clamp(1 - dx / max, 0, 1);
        const distance = Math.round(lerp(settings.baseCast, settings.maxCast, closeness));
        startFlight(distance);
      };
      bar.addEventListener('click', stop);
    }

    function startFlight(dist) {
      state = GameState.Flight;
      world.castDistance = dist;
      world.bobberDist = 0;
      const metrics = getEnvironmentMetrics(canvas.clientWidth, canvas.clientHeight);
      const spawnInfo = spawnFishes(dist, metrics, canvas.clientWidth);
      world.fishes = spawnInfo.fishes;
      world.actives = []; 
      world.catches = [];
      world.time = 0;
      startCharacterCastAnimation();
      distanceEl.style.display = 'block';
      minimap.style.display = 'none';
    }

    function startFishing() {
      state = GameState.Fishing;
      world.bobberDist = world.castDistance;
      minimap.style.display = 'block';
      distanceEl.style.display = 'block';
    }

    let rIndex = 0;
    function showResults() {
      state = GameState.Results;
      rIndex = 0;
      results.style.display = 'flex';
      minimap.style.display = 'none';
      renderResultCard();
    }

    function renderResultCard() {
      const count = world.catches.length;
      if (rIndex >= count) {
        rTitle.textContent = 'All Done!';
        rBody.innerHTML = '<p>Great fishing session!</p>';
        rNext.textContent = 'Continue';
        return;
      }

      const fish = world.catches[rIndex];
      const points = computePoints(fish, world.castDistance);
      settings.points += points;
      setHUD();

      rTitle.textContent = `Catch ${rIndex + 1}/${count}`;
      rBody.innerHTML = `
        <div style="margin: 20px 0;">
          <h4 style="color: ${fish.spec.ui.mapColorHex}; margin-bottom: 10px;">${fish.spec.displayName}</h4>
          <p><strong>Size:</strong> ${fish.size_cm.toFixed(1)} cm</p>
          <p><strong>Weight:</strong> ${fish.weight_kg.toFixed(2)} kg</p>
          <p><strong>Rarity:</strong> ${fish.spec.rarity}</p>
          <p><strong>Points:</strong> ${points}</p>
        </div>
      `;
      rNext.textContent = rIndex < count - 1 ? 'Next' : 'Continue';
    }

    function updateMinimap() {
      if (!mmbar) return;
      
      mmbar.innerHTML = '<div class="mmcenter"></div>';
      
      const mapWidth = 120;
      const mapHeight = 60;
      const range = 26;
      
      for (const fish of world.fishes) {
        if (!fish || fish.finished) continue;
        
        const fishX = fish.position?.x ?? 0;
        const fishY = fish.position?.y ?? fish.distance;
        
        const dx = fishX;
        const dy = fishY - world.bobberDist;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= DETECTION_RANGE_M) {
          const dot = document.createElement('div');
          dot.style.position = 'absolute';
          dot.style.width = '4px';
          dot.style.height = '4px';
          dot.style.backgroundColor = fish.iconColor;
          dot.style.borderRadius = '50%';
          dot.style.left = (mapWidth * 0.5 + (fishX / range) * mapWidth * 0.4) + 'px';
          dot.style.top = (mapHeight * 0.5 + (dy / range) * mapHeight * 0.4) + 'px';
          dot.style.transform = 'translate(-50%, -50%)';
          
          if (fish.engaged) {
            dot.style.border = '1px solid white';
            dot.style.width = '6px';
            dot.style.height = '6px';
          }
          
          mmbar.appendChild(dot);
        }
      }
      
      const rangeCircle = document.createElement('div');
      rangeCircle.style.position = 'absolute';
      rangeCircle.style.left = '50%';
      rangeCircle.style.top = '50%';
      rangeCircle.style.transform = 'translate(-50%, -50%)';
      rangeCircle.style.width = (DETECTION_RANGE_M / range * mapWidth * 0.8) + 'px';
      rangeCircle.style.height = (DETECTION_RANGE_M / range * mapHeight * 0.8) + 'px';
      rangeCircle.style.border = '1px solid rgba(91, 192, 190, 0.5)';
      rangeCircle.style.borderRadius = '50%';
      rangeCircle.style.pointerEvents = 'none';
      mmbar.appendChild(rangeCircle);
    }

    // === 렌더링 함수 ===
    function render() {
      if (!canvas || !ctx) return;

      const W = canvas.width;
      const H = canvas.height;
      
      ctx.clearRect(0, 0, W, H);
      
      const metrics = getEnvironmentMetrics(W, H);
      
      drawEnvironment(W, H, metrics, camera.y);
      drawCharacterSprite(W, H, metrics, camera.y);
      
      if (state === GameState.Flight) {
        const progress = Math.min(world.time / 1.5, 1);
        world.bobberDist = lerp(0, world.castDistance, progress);
        
        if (progress >= 1) {
          startFishing();
        }
        
        const distancePx = world.bobberDist * metrics.pxPerMeter;
        const bobberWorldY = metrics.waterSurfaceY - distancePx;
        const bobberScreenY = bobberWorldY + camera.y;
        const bobberX = W * 0.5 + metrics.bobberOffsetX;
        
        drawFishingLine(rodAnchor.x, rodAnchor.y, bobberX, bobberScreenY);
        drawBobber(bobberX, bobberScreenY);
        
      } else if (state === GameState.Fishing) {
        const distancePx = world.bobberDist * metrics.pxPerMeter;
        const bobberWorldY = metrics.waterSurfaceY - distancePx;
        const bobberScreenY = bobberWorldY + camera.y;
        const bobberX = W * 0.5 + metrics.bobberOffsetX;
        
        drawFishingLine(rodAnchor.x, rodAnchor.y, bobberX, bobberScreenY);
        drawBobber(bobberX, bobberScreenY);
        
        for (const fish of world.fishes) {
          if (!fish || fish.finished) continue;
          
          const fishDistPx = (fish.position?.y ?? fish.distance) * metrics.pxPerMeter;
          const fishWorldY = metrics.waterSurfaceY - fishDistPx;
          const fishScreenY = fishWorldY + camera.y;
          const fishScreenX = W * 0.5 + (fish.position?.x ?? 0) * (W * 0.008);
          
          if (fishScreenY < -50 || fishScreenY > H + 50 || fishScreenX < -50 || fishScreenX > W + 50) {
            continue;
          }
          
          const fishImage = gameData.resources.fish.get(fish.specId);
          if (fishImage) {
            const fishScale = 0.8;
            const fishW = fishImage.width * fishScale;
            const fishH = fishImage.height * fishScale;
            ctx.drawImage(fishImage, fishScreenX - fishW/2, fishScreenY - fishH/2, fishW, fishH);
          } else {
            // 향상된 폴백: 물고기 모양 그리기
            const fishSize = 12;
            ctx.fillStyle = fish.iconColor;
            
            // 물고기 몸체 (타원형)
            ctx.beginPath();
            ctx.ellipse(fishScreenX, fishScreenY, fishSize, fishSize * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 물고기 꼬리
            ctx.beginPath();
            ctx.moveTo(fishScreenX - fishSize, fishScreenY);
            ctx.lineTo(fishScreenX - fishSize - 8, fishScreenY - 6);
            ctx.lineTo(fishScreenX - fishSize - 8, fishScreenY + 6);
            ctx.closePath();
            ctx.fill();
            
            // 물고기 지느러미
            ctx.fillStyle = `${fish.iconColor}80`; // 반투명
            ctx.beginPath();
            ctx.ellipse(fishScreenX + 2, fishScreenY - 8, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 물고기 눈
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(fishScreenX + 4, fishScreenY - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(fishScreenX + 4, fishScreenY - 2, 1, 0, Math.PI * 2);
            ctx.fill();
          }
          
          if (fish.engaged) {
            ctx.strokeStyle = fish.iconColor;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(fishScreenX, fishScreenY, 15, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }
        
        updateActiveCircles(1/60, bobberX, bobberScreenY, metrics, camera.y);
        updateMinimap();
      }
      
      if (state === GameState.Flight || state === GameState.Fishing) {
        distanceEl.textContent = `Distance: ${Math.round(world.bobberDist)}m`;
      }
    }

    // === 게임 루프 ===
    let lastTime = 0;
    function gameLoop(currentTime) {
      const dt = Math.min((currentTime - lastTime) / 1000, 1/30);
      lastTime = currentTime;
      globalTime += dt;
      world.time += dt;
      
      updateCharacterAnimation(dt);
      updateFishSimulation(dt);
      
      if (state === GameState.Flight || state === GameState.Fishing) {
        const metrics = getEnvironmentMetrics(canvas.width, canvas.height);
        updateCamera(world.bobberDist, metrics, dt, state);
      }
      
      render();
      requestAnimationFrame(gameLoop);
    }

    // === 게임 시작 ===
    document.addEventListener('DOMContentLoaded', async () => {
      await init();
      requestAnimationFrame(gameLoop);
    });

    // 에너지 회복 시스템
    setInterval(() => {
      if (settings.energy < 10) {
        settings.energy++;
        setHUD();
      }
    }, 30000);
  </script>
</body>
</html>